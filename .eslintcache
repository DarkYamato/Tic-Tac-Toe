[{"/Users/darkyamato/testing/tic-tac-toe/src/index.js":"1","/Users/darkyamato/testing/tic-tac-toe/src/App.js":"2","/Users/darkyamato/testing/tic-tac-toe/src/reportWebVitals.js":"3","/Users/darkyamato/testing/tic-tac-toe/src/components/Board.js":"4","/Users/darkyamato/testing/tic-tac-toe/src/components/Cell.js":"5"},{"size":500,"mtime":1606828348107,"results":"6","hashOfConfig":"7"},{"size":175,"mtime":1606829299362,"results":"8","hashOfConfig":"7"},{"size":362,"mtime":1606828348110,"results":"9","hashOfConfig":"7"},{"size":4303,"mtime":1606845657667,"results":"10","hashOfConfig":"7"},{"size":157,"mtime":1606829388218,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"t1ncxk",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"14"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/darkyamato/testing/tic-tac-toe/src/index.js",[],["24","25"],"/Users/darkyamato/testing/tic-tac-toe/src/App.js",[],"/Users/darkyamato/testing/tic-tac-toe/src/reportWebVitals.js",[],"/Users/darkyamato/testing/tic-tac-toe/src/components/Board.js",["26","27"],"import { useState, useEffect } from \"react\";\nimport { Cell } from \"./Cell\";\n\nimport \"./Board.css\";\n\nconst combo = [\n  [0, 1, 2],\n  [3, 4, 5],\n  [6, 7, 8],\n  [0, 3, 6],\n  [1, 4, 7],\n  [2, 5, 8],\n  [0, 4, 8],\n  [2, 4, 6],\n];\n\nconst mark = {\n  X: \"X\",\n  O: \"O\",\n};\n\nexport const Board = () => {\n  const [cells, setCells] = useState(Array(9).fill(null));\n  const [isXturn, setIsXTurn] = useState(true);\n  const [winner, setWinner] = useState(null);\n  const { X, O } = mark;\n\n  useEffect(() => {\n    if (!isXturn) {\n      computerStep();\n    }\n  }, [isXturn]);\n\n  useEffect(() => {\n    getWinner();\n  }, [cells]);\n\n  const handleClick = (i) => {\n    const newCells = cells.slice();\n\n    if (!isXturn || cells[i] || winner) {\n      return;\n    }\n\n    newCells[i] = isXturn ? X : O;\n    setCells(newCells);\n    setIsXTurn((prevIsXturn) => !prevIsXturn);\n  };\n\n  const computerStep = () => {\n    const firstStep = !cells.some((x) => x === O);\n\n    if (firstStep) {\n      if (!cells[4]) {\n        updateCellsByComputer(4);\n      } else {\n        updateCellsByComputer(0);\n      }\n    } else {\n      const computerIdxs = cells\n        .reduce((acc, x, i) => acc.concat(x === O && i), [])\n        .filter((x) => x !== false);\n      const userIdxs = cells\n        .reduce((acc, x, i) => acc.concat(x === X && i), [])\n        .filter((x) => x !== false);\n\n      const computerWinIds = findIndexForCombo(computerIdxs, 1);\n      const userWinIds = findIndexForCombo(userIdxs, 1);\n\n      if (computerWinIds.length) {\n        // Checking if we can finish the game in one move\n        updateCellsByComputer(computerWinIds[0]);\n      } else if (userWinIds.length) {\n        // Checking if we can mess up the combo for the user\n        updateCellsByComputer(userWinIds[0]);\n      } else {\n        const bestStep = findIndexForCombo(computerIdxs, 2);\n        updateCellsByComputer(bestStep[0]);\n      }\n    }\n  };\n\n  const updateCellsByComputer = (idx) => {\n    const newCells = cells.slice();\n    newCells[idx] = O;\n    setTimeout(() => {\n      setCells(newCells);\n      setIsXTurn((prevIsXturn) => !prevIsXturn);\n    }, 400);\n  };\n\n  const findIndexForCombo = (arr, length) => {\n    /**\n     * @param arr is currently selected ids\n     * @param length step for filtering array of combos\n     * @returns an array of combos remaining for a successful combination\n     */\n\n    const availableIdxs = cells\n      .reduce((acc, x, i) => acc.concat(x === null && i), [])\n      .filter((x) => x !== false);\n\n    // Remove matching elements from the array of combos, filter and flat\n    const filteredMatchCombo = combo\n      .map((x) => x.filter((x) => !arr.includes(x)))\n      .filter((x) => x.length === length)\n      .flat(2);\n\n    const indexesForSelect = filteredMatchCombo.filter((x) =>\n      availableIdxs.includes(x)\n    );\n\n    return indexesForSelect;\n  };\n\n  const handleClear = () => {\n    setCells(Array(9).fill(null));\n    setIsXTurn(true);\n    setWinner(null);\n  };\n\n  const renderCell = (i) => (\n    <Cell value={cells[i]} onClick={() => handleClick(i)} />\n  );\n\n  const getWinner = () => {\n    combo.forEach((item, i) => {\n      const [x, y, z] = combo[i];\n      if (cells[x] !== null && cells[x] === cells[y] && cells[x] === cells[z]) {\n        setWinner(cells[x]);\n      }\n      return null;\n    });\n  };\n\n  const noWinner = !winner && !cells.includes(null);\n\n  let status;\n\n  if (winner) {\n    status = `Winner is ${winner}`;\n  } else if (noWinner) {\n    status = \"No winner\";\n  } else {\n    status = isXturn ? \"Current Player: X\" : \"Current Player: O\";\n  }\n\n  return (\n    <div className=\"container\">\n      <div>\n        <div className=\"status\">{status}</div>\n        <table>\n          <tbody>\n            <tr>\n              <td>{renderCell(0)}</td>\n              <td>{renderCell(1)}</td>\n              <td>{renderCell(2)}</td>\n            </tr>\n            <tr>\n              <td>{renderCell(3)}</td>\n              <td>{renderCell(4)}</td>\n              <td>{renderCell(5)}</td>\n            </tr>\n            <tr>\n              <td>{renderCell(6)}</td>\n              <td>{renderCell(7)}</td>\n              <td>{renderCell(8)}</td>\n            </tr>\n          </tbody>\n        </table>\n        <button className=\"clear\" onClick={handleClear}>\n          clear\n        </button>\n      </div>\n    </div>\n  );\n};\n","/Users/darkyamato/testing/tic-tac-toe/src/components/Cell.js",[],{"ruleId":"28","replacedBy":"29"},{"ruleId":"30","replacedBy":"31"},{"ruleId":"32","severity":1,"message":"33","line":32,"column":6,"nodeType":"34","endLine":32,"endColumn":15,"suggestions":"35"},{"ruleId":"32","severity":1,"message":"36","line":36,"column":6,"nodeType":"34","endLine":36,"endColumn":13,"suggestions":"37"},"no-native-reassign",["38"],"no-negated-in-lhs",["39"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'computerStep'. Either include it or remove the dependency array.","ArrayExpression",["40"],"React Hook useEffect has a missing dependency: 'getWinner'. Either include it or remove the dependency array.",["41"],"no-global-assign","no-unsafe-negation",{"desc":"42","fix":"43"},{"desc":"44","fix":"45"},"Update the dependencies array to be: [computerStep, isXturn]",{"range":"46","text":"47"},"Update the dependencies array to be: [cells, getWinner]",{"range":"48","text":"49"},[544,553],"[computerStep, isXturn]",[599,606],"[cells, getWinner]"]